# -*- coding: utf-8 -*-
# Page-wise image -> JSON using horizon_api.vision_structure
# Each page's prompt is formatted with:
#   {ACCEPTABLE_SECTION_HEADERS}  -> contents of acceptable_section_headers.txt
#   {OCR_TEXT}                    -> contents of matching page-*.txt

import asyncio
import json
import mimetypes
import traceback
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Tuple

from horizon_api import vision_structure  # must be awaitable: (schema, prompt, files) -> dict


# ----------------------------- configuration ----------------------------- #

# Roots (adjust if your folder names differ)
INPUT_IMG_ROOT  = Path("Output files/HELIX (Member cases - 8)/pdf_to_images")
INPUT_OCR_ROOT  = Path("Output files/HELIX (Member cases - 8)/md_to_pagewise_txt")
OUTPUT_JSON_ROOT = Path("Output files/HELIX (Member cases - 8)/image_to_json_with_subsection")
ERROR_LOG        = Path("Output files/HELIX (Member cases - 8)/errors/image_to_json_with_subsection/failed_pages.txt")

# Prompt & schema
PROMPT_FILE      = Path("prompts/image_to_json_with_subsection.txt")  # must contain {ACCEPTABLE_SECTION_HEADERS} and {OCR_TEXT}
ACCEPTABLE_LIST  = Path("acceptable_section_headers.txt")
SCHEMA_FILE      = Path("schemas/with_acceptable_and_subsection.json")

MAX_CONCURRENCY  = 5  # tune as needed


# ----------------------------- helpers ----------------------------- #

def _mime(path: Path) -> str:
    return mimetypes.guess_type(path.name)[0] or "application/octet-stream"

def _read_text(path: Path) -> str:
    return path.read_text(encoding="utf-8")

def _write_json(path: Path, obj: Dict) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(json.dumps(obj, ensure_ascii=False, indent=2), encoding="utf-8")

def _append_error(log_path: Path, img: Path, exc: BaseException) -> None:
    log_path.parent.mkdir(parents=True, exist_ok=True)
    with log_path.open("a", encoding="utf-8") as fp:
        fp.write(f"[{datetime.now():%Y-%m-%d %H:%M:%S}] {img}\n{type(exc).__name__}: {exc}\n{traceback.format_exc()}\n{'-'*80}\n")


# ----------------------------- core worker ----------------------------- #

async def _process_page(
    img_path: Path,
    img_root: Path,
    ocr_root: Path,
    out_root: Path,
    prompt_template: str,
    acceptables_text: str,
    schema: Dict,
    sem: asyncio.Semaphore,
    error_log: Path,
) -> None:
    """
    For a given image:
      - find matching OCR page text under ocr_root with same relative path
      - format prompt with {ACCEPTABLE_SECTION_HEADERS} and {OCR_TEXT}
      - call vision_structure and write JSON beside out_root preserving tree
    """
    rel = img_path.relative_to(img_root)                       # e.g. UUID/page-1.jpg
    json_out = (out_root / rel).with_suffix(".json")           # e.g. .../image_to_json_with_subsection/UUID/page-1.json
    ocr_path = (ocr_root / rel).with_suffix(".txt")            # e.g. .../md_to_pagewise_txt/UUID/page-1.txt

    if json_out.exists():
        print(f"✓ exists: {json_out}")
        return

    if not ocr_path.exists():
        _append_error(error_log, img_path, FileNotFoundError(f"OCR text not found: {ocr_path}"))
        print(f"✗ missing OCR: {img_path}")
        return

    try:
        ocr_text = _read_text(ocr_path)

        # Build the page-specific prompt
        prompt = prompt_template.format(
            ACCEPTABLE_SECTION_HEADERS=acceptables_text,
            OCR_TEXT=ocr_text
        )

        async with sem:
            with img_path.open("rb") as fh:
                files: List[Tuple[str, Tuple[str, object, str]]] = [
                    ("image", (img_path.name, fh, _mime(img_path)))
                ]
                response: Dict = await vision_structure(schema, prompt, files)

        _write_json(json_out, response)
        print(f"✓ saved: {json_out}")

    except Exception as e:
        _append_error(error_log, img_path, e)
        print(f"✗ failed: {img_path}")


# ----------------------------- driver ----------------------------- #

async def vision_extract_parallel() -> None:
    """
    Convert every *.jpg under INPUT_IMG_ROOT to JSON under OUTPUT_JSON_ROOT.
    Page requests run in parallel, each page prompt includes its matching OCR text.
    """
    # Load prompt template, acceptable list, schema once
    prompt_template = _read_text(PROMPT_FILE)
    acceptables_text = _read_text(ACCEPTABLE_LIST)
    schema: Dict = json.loads(_read_text(SCHEMA_FILE))

    # Find all images
    img_paths = sorted(INPUT_IMG_ROOT.rglob("*.jpg"))
    if not img_paths:
        raise FileNotFoundError(f"No JPG images found under: {INPUT_IMG_ROOT}")

    # Run
    sem = asyncio.Semaphore(MAX_CONCURRENCY)
    tasks = [
        asyncio.create_task(
            _process_page(
                img_path=img,
                img_root=INPUT_IMG_ROOT,
                ocr_root=INPUT_OCR_ROOT,
                out_root=OUTPUT_JSON_ROOT,
                prompt_template=prompt_template,
                acceptables_text=acceptables_text,
                schema=schema,
                sem=sem,
                error_log=ERROR_LOG,
            )
        )
        for img in img_paths
    ]
    await asyncio.gather(*tasks)
    print("Finished. Any failures were logged.")


# ----------------------------- entry point ----------------------------- #

if __name__ == "__main__":
    asyncio.run(vision_extract_parallel())
