from pathlib import Path
import re
from typing import Dict, List

def verify_prompt_image_parity(
    prompt_root: str | Path,
    image_root: str | Path,
    prompt_rx: str = r"^prompt__([0-9]+)\.txt$",
    image_rx: str  = r"^page[-_]{1,2}([0-9]+)\.(?:jpe?g|png|webp|tif|tiff|bmp)$",
) -> Dict[str, dict]:
    """
    Compares counts & page numbers between prompts and images per UUID folder.

    Expects trees like:
      prompt_root/<uuid>/<any-doc-name>/prompt__N.txt
      image_root/<uuid>/<any-doc-name>/page- N .jpg (or page__N / page_N)

    If a UUID contains multiple doc subfolders on either side, it will compare totals and
    also list per-subfolder counts so mismatches are obvious.
    """
    prompt_root = Path(prompt_root)
    image_root  = Path(image_root)
    if not prompt_root.exists():
        raise FileNotFoundError(f"Prompt root not found: {prompt_root}")
    if not image_root.exists():
        raise FileNotFoundError(f"Image root not found:  {image_root}")

    rx_p = re.compile(prompt_rx, re.IGNORECASE)
    rx_i = re.compile(image_rx,  re.IGNORECASE)

    # Helper: get page numbers inside a doc dir
    def collect_pages(dir_path: Path, rx) -> List[int]:
        pages = []
        for f in dir_path.iterdir():
            if f.is_file():
                m = rx.match(f.name)
                if m:
                    pages.append(int(m.group(1)))
        pages.sort()
        return pages

    uuids = sorted({p.name for p in prompt_root.iterdir() if p.is_dir()} |
                   {p.name for p in image_root.iterdir()  if p.is_dir()})

    report: Dict[str, dict] = {}
    print("\n=== Prompt ↔ Image Parity Check ===")

    for uid in uuids:
        p_uuid = prompt_root / uid
        i_uuid = image_root  / uid

        p_docs = [d for d in p_uuid.iterdir() if d.is_dir()] if p_uuid.exists() else []
        i_docs = [d for d in i_uuid.iterdir() if d.is_dir()] if i_uuid.exists() else []

        # Per-subfolder tallies
        p_info = {}
        i_info = {}

        for d in p_docs:
            pages = collect_pages(d, rx_p)
            p_info[d.name] = {"count": len(pages), "pages": pages}

        for d in i_docs:
            pages = collect_pages(d, rx_i)
            i_info[d.name] = {"count": len(pages), "pages": pages}

        # Totals per UUID
        p_total = sum(v["count"] for v in p_info.values())
        i_total = sum(v["count"] for v in i_info.values())
        counts_match = (p_total == i_total)

        # If there is exactly one subfolder on each side, also do a direct page comparison
        pages_match = None
        pair_key = None
        if len(p_info) == 1 and len(i_info) == 1:
            p_name = next(iter(p_info))
            i_name = next(iter(i_info))
            pair_key = f"{p_name} ↔ {i_name}"
            pages_match = (p_info[p_name]["pages"] == i_info[i_name]["pages"])

        key = uid
        report[key] = {
            "prompt_total": p_total,
            "image_total":  i_total,
            "counts_match": counts_match,
            "pair_pages_match": pages_match,
            "pair": pair_key,
            "prompt_docs": p_info,
            "image_docs":  i_info,
        }

        # -------- print summary --------
        if not p_docs and i_docs:
            print(f"[MISSING] {uid}: no prompt folder(s); images present ({i_total})")
        elif p_docs and not i_docs:
            print(f"[MISSING] {uid}: no image folder(s); prompts present ({p_total})")
        else:
            if counts_match:
                if pages_match is True:
                    print(f"[OK]      {uid}: {p_total} prompts ↔ {i_total} images (pages match in {pair_key})")
                else:
                    print(f"[OK*]     {uid}: {p_total} prompts ↔ {i_total} images "
                          f"(multiple subfolders or page sets differ; see details)")
            else:
                print(f"[MISMATCH] {uid}: prompts={p_total} images={i_total} — see details below.")

            # Show per-subfolder counts (helps when names differ)
            for name, v in p_info.items():
                print(f"          P: {name}: {v['count']} ({v['pages'][:5]}{'...' if len(v['pages'])>5 else ''})")
            for name, v in i_info.items():
                print(f"          I: {name}: {v['count']} ({v['pages'][:5]}{'...' if len(v['pages'])>5 else ''})")

    return report


prompt_root = "/path/to/prompt_input"          # where prompt__*.txt live
image_root  = "/path/to/Output_Files_08_08_2025"  # where page-*.jpg live

report = verify_prompt_image_parity(prompt_root, image_root)
