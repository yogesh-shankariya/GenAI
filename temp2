from pathlib import Path
import re
from typing import Dict, Tuple, List

def check_prompt_image_match(
    prompt_root: str | Path,
    image_root: str | Path,
    prompt_rx: str = r"^prompt_{1,2}([0-9]+)\.txt$",
    image_rx:  str = r"^page[-_]{1,2}([0-9]+)\.(?:jpe?g|png|webp|tif|tiff|bmp)$",
) -> Dict[str, Dict[str, dict]]:
    """
    Compare prompts vs images *per UUID and per doc folder*.
    We expect trees like:
      prompt_root/<UUID>/<doc-folder>/prompt__N.txt   (or prompt_N.txt)
      image_root/<UUID>/<doc-folder>/page- N .jpg     (or page_N / page__N)

    Returns: { UUID: { rel_doc: {prompt_count, image_count, counts_match,
                                 prompt_pages, image_pages, pages_match,
                                 missing_prompts_for_pages, missing_images_for_pages,
                                 pairs: [(page, image_path, prompt_path)] } } }
    Also prints a concise summary.
    """
    prompt_root = Path(prompt_root)
    image_root  = Path(image_root)
    if not prompt_root.exists():
        raise FileNotFoundError(f"Prompt root not found: {prompt_root}")
    if not image_root.exists():
        raise FileNotFoundError(f"Image root not found:  {image_root}")

    rx_p = re.compile(prompt_rx, re.IGNORECASE)
    rx_i = re.compile(image_rx,  re.IGNORECASE)

    def collect(root: Path, rx) -> Dict[Tuple[str, str], Dict[int, Path]]:
        """
        Walk root/** and collect by (uuid, rel_doc).
        rel_doc is path of the file's parent relative to <root>/<uuid>.
        """
        out: Dict[Tuple[str, str], Dict[int, Path]] = {}
        for uuid_dir in (d for d in root.iterdir() if d.is_dir()):
            for f in uuid_dir.rglob("*"):
                if f.is_file():
                    m = rx.match(f.name)
                    if not m:
                        continue
                    page = int(m.group(1))
                    rel_doc = str(f.parent.relative_to(uuid_dir))  # e.g. "input^FILE_NAME_..."; "." if same
                    key = (uuid_dir.name, rel_doc)
                    out.setdefault(key, {})
                    # keep the first occurrence if duplicates show up
                    out[key].setdefault(page, f)
        return out

    prompts = collect(prompt_root, rx_p)
    images  = collect(image_root,  rx_i)

    # All (uuid, rel_doc) pairs we saw anywhere
    all_keys = set(prompts) | set(images)

    report: Dict[str, Dict[str, dict]] = {}
    print("\n=== Prompt â†” Image Match (per UUID/doc) ===")
    for uuid, rel_doc in sorted(all_keys):
        p_pages = prompts.get((uuid, rel_doc), {})
        i_pages = images.get((uuid, rel_doc), {})

        p_nums = sorted(p_pages.keys())
        i_nums = sorted(i_pages.keys())

        counts_match = (len(p_nums) == len(i_nums))
        pages_match  = (p_nums == i_nums)

        miss_prompts = sorted(set(i_nums) - set(p_nums))
        miss_images  = sorted(set(p_nums) - set(i_nums))

        pairs = [(n, i_pages[n], p_pages[n]) for n in sorted(set(p_nums) & set(i_nums))]

        # pretty key for printing
        doc_label = rel_doc if rel_doc != "." else "(root)"
        status = "[OK]" if counts_match and pages_match else "[MISMATCH]"
        print(f"{status} {uuid} / {doc_label}: prompts={len(p_nums)} images={len(i_nums)} pages_equal={pages_match}")
        if miss_prompts:
            print(f"   missing prompts for pages: {miss_prompts}")
        if miss_images:
            print(f"   missing images  for pages: {miss_images}")

        report.setdefault(uuid, {})
        report[uuid][rel_doc] = {
            "prompt_count": len(p_nums),
            "image_count":  len(i_nums),
            "counts_match": counts_match,
            "pages_match":  pages_match,
            "prompt_pages": p_nums,
            "image_pages":  i_nums,
            "missing_prompts_for_pages": miss_prompts,
            "missing_images_for_pages": miss_images,
            "pairs": pairs,   # (page_num, image_path, prompt_path)
        }

    return report


prompt_root = "/path/to/Prompt_Inputs"          # where prompt_*.txt live
image_root  = "/path/to/Output_Files_08_08_2025"  # where page-*.jpg live

report = check_prompt_image_match(prompt_root, image_root)
