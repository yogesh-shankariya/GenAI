from pathlib import Path
import re

DEFAULT_PROMPT = """You are a document-structure extraction assistant.

## Task
You will be given a JPG image of a scanned medical document page.
Identify every section header that belongs to this page.

Ignore anything that is obviously a field label, table column, or data value.

## Output format
Return only the JSON object below—no extra keys, commentary, or text:
{"section_headers": ["<header-1>", "<header-2>", "..."]}

## Extraction rules
1) Rotate mentally if needed so text reads upright.
2) Perform high-accuracy OCR across the entire page, reading order (top→bottom, left→right).
3) Preserve the distinct words, capitalization, and punctuation from the image.
4) Prefer the specific, non-generic headers that denote new sections.
5) List each header once; omit duplicates and subsection captions.
6) If no valid headers are found, return an empty list.

## Important
At the end of this prompt you will see OCR text extracted from the page.
You MAY use it as reference only. It can be noisy/incomplete—do NOT assume it is 100% correct.
If the OCR text conflicts with the image, the image is authoritative.
"""

def make_page_prompts(
    page_txt_root: str | Path,
    prompt_output_root: str | Path,
    base_prompt_file: str | Path | None = None,
) -> None:
    """
    Input:  <page_txt_root>/<file-id>/<md-stem>/page__N.txt
    Output: <prompt_output_root>/<file-id>/<md-stem>/prompt__N.txt
    """
    page_txt_root = Path(page_txt_root)
    prompt_output_root = Path(prompt_output_root)
    if not page_txt_root.exists():
        raise FileNotFoundError(page_txt_root)

    base_prompt = (
        Path(base_prompt_file).read_text(encoding="utf-8", errors="ignore")
        if base_prompt_file else DEFAULT_PROMPT
    )

    page_rx = re.compile(r"^page__([0-9]+)\.txt$", re.IGNORECASE)

    for file_id_dir in sorted(p for p in page_txt_root.iterdir() if p.is_dir()):
        for md_stem_dir in sorted(p for p in file_id_dir.iterdir() if p.is_dir()):
            pairs = []
            for pf in md_stem_dir.glob("page__*.txt"):
                m = page_rx.match(pf.name)
                if m:
                    pairs.append((int(m.group(1)), pf))
            if not pairs:
                continue
            pairs.sort(key=lambda t: t[0])

            out_dir = prompt_output_root / file_id_dir.name / md_stem_dir.name
            out_dir.mkdir(parents=True, exist_ok=True)

            for page_num, pf in pairs:
                ocr_text = pf.read_text(encoding="utf-8", errors="ignore").strip()
                final_prompt = (
                    f"{base_prompt.strip()}\n\n"
                    f"## Page Context\n"
                    f"File ID: {file_id_dir.name}\n"
                    f"Document: {md_stem_dir.name}\n"
                    f"Page: {page_num}\n\n"
                    f"--- BEGIN_OCR_TEXT (reference only) ---\n"
                    f"{ocr_text}\n"
                    f"--- END_OCR_TEXT ---\n"
                )
                (out_dir / f"prompt__{page_num}.txt").write_text(final_prompt, encoding="utf-8")

    print(f"Done. Prompts written under: {prompt_output_root}")
