"""
Utility script for splitting OCR text files into page‑based chunks.

This module operates on plain‐text files that represent OCR outputs of
PDF documents.  Each page of the original PDF is delimited in the
text by a marker of the form ``<ocr_service_page_start>n<ocr_service_page_start>``,
where ``n`` is the 1‑based page number.  For example, the content
between ``<ocr_service_page_start>1<ocr_service_page_start>`` and
``<ocr_service_page_start>2<ocr_service_page_start>`` corresponds to
the first page.

The primary entry point is ``split_ocr_texts`` which takes a root
directory containing OCR text files, scans every ``.txt`` file, and
produces new files for those that exceed a specified page limit.  If
a file contains more than ``page_limit`` pages, it is split into
multiple files, each containing at most ``page_limit`` pages, with
suffixed names like ``filename_1.txt``, ``filename_2.txt``, etc.
Files with ``page_limit`` pages or fewer are copied unchanged to the
destination directory.  The input directory hierarchy is preserved
under the destination root.

Example usage::

    from pathlib import Path
    from data_preprocessing_step_doc import split_ocr_texts

    input_root = Path("/path/to/ocr_outputs")
    output_root = Path("/path/to/split_outputs")
    split_ocr_texts(input_root, output_root, page_limit=10)

After running this, ``output_root`` will mirror ``input_root`` but
files containing more than 10 pages will be broken into multiple
chunks of 10 pages each (final chunk may have fewer pages).
"""

from __future__ import annotations

import re
import shutil
from pathlib import Path
from typing import List, Tuple

PAGE_START_PATTERN = re.compile(r"<ocr_service_page_start>\d+<ocr_service_page_start>")


def _find_page_segments(text: str) -> List[str]:
    """Split the given OCR text into per‐page segments.

    The input text is expected to contain markers of the form
    ``<ocr_service_page_start>n<ocr_service_page_start>``.  This
    function returns a list of strings, each representing one page
    including its starting marker.  The final segment runs to the
    end of the string.

    Args:
        text: Entire contents of an OCR text file.

    Returns:
        A list of per‑page strings.  If no page markers are found,
        the list will contain a single element equal to ``text``.
    """
    matches = list(PAGE_START_PATTERN.finditer(text))
    if not matches:
        return [text]
    segments: List[str] = []
    # Include any content before the first marker as the start of the first page
    # If the first marker is not at position 0, include prefix
    if matches[0].start() > 0:
        # preface goes with the first page
        prefix = text[: matches[0].start()]
    else:
        prefix = ""
    for idx, match in enumerate(matches):
        start = match.start()
        end = matches[idx + 1].start() if idx + 1 < len(matches) else len(text)
        page_str = text[start:end]
        if idx == 0 and prefix:
            page_str = prefix + page_str
        segments.append(page_str)
    return segments


def split_txt_file(
    txt_path: Path,
    input_root: Path,
    dest_root: Path,
    *,
    page_limit: int = 10,
) -> None:
    """Split a single OCR text file into page‑limited chunks.

    If the file contains more pages than ``page_limit``, multiple
    output files will be created with suffixed names.  Otherwise, the
    file is copied verbatim to the destination.  The output files are
    placed in the destination root, preserving the relative path of
    the input.

    Args:
        txt_path: Path to the source ``.txt`` file.
        dest_root: Root directory where output files are written.
        page_limit: Maximum number of pages per output file.
    """
    # Compute relative path with respect to the input root.  This ensures that
    # the directory structure under input_root is mirrored under dest_root.
    # If txt_path is not under input_root, the relative_to call will raise
    # ValueError; in that case fall back to using the filename directly.
    try:
        rel_path = txt_path.relative_to(input_root)
    except ValueError:
        rel_path = Path(txt_path.name)

    # Ensure destination directory exists
    out_dir = dest_root / rel_path.parent
    out_dir.mkdir(parents=True, exist_ok=True)

    # Read file contents
    try:
        text = txt_path.read_text(encoding="utf-8")
    except Exception:
        # Binary or unreadable file; copy as is
        shutil.copy2(txt_path, out_dir / txt_path.name)
        return

    # Split into pages
    pages = _find_page_segments(text)
    num_pages = len(pages)

    if num_pages <= page_limit:
        # Write original content to destination with the same filename
        out_file = out_dir / txt_path.name
        out_file.write_text(text, encoding="utf-8")
        return

    # Build and write chunks
    chunk_count = (num_pages + page_limit - 1) // page_limit
    for idx in range(chunk_count):
        start_page = idx * page_limit
        end_page = min(start_page + page_limit, num_pages)
        chunk_pages = pages[start_page:end_page]
        # Join pages without extra delimiter; original markers are preserved
        chunk_text = "".join(chunk_pages)
        # Construct new filename: original stem suffixed with _n.txt
        stem = txt_path.stem
        suffix = f"_{idx + 1}"
        new_name = f"{stem}{suffix}.txt"
        out_path = out_dir / new_name
        out_path.write_text(chunk_text, encoding="utf-8")


def split_ocr_texts(
    input_root: Path,
    output_root: Path,
    *,
    page_limit: int = 10,
) -> None:
    """Process all ``.txt`` files under ``input_root`` and split them.

    This function recursively walks the ``input_root`` directory.  For
    each file ending with ``.txt`` it calls ``split_txt_file`` to
    either copy or split the file based on the number of pages.  Files
    that are split produce suffixed outputs in the mirrored directory
    structure under ``output_root``.  Non-``.txt`` files are ignored.

    Args:
        input_root: Top-level directory containing OCR text files.
        output_root: Destination directory where split files will be written.
        page_limit: Maximum pages per output chunk.
    """
    input_root = Path(input_root)
    output_root = Path(output_root)
    for path in input_root.rglob("*.txt"):
        split_txt_file(path, input_root, output_root, page_limit=page_limit)


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Split OCR text files into page-limited chunks.")
    parser.add_argument("input_root", help="Directory containing OCR text files")
    parser.add_argument("output_root", help="Directory to write split files")
    parser.add_argument(
        "--page-limit",
        type=int,
        default=10,
        help="Maximum pages per output file (default: 10)",
    )
    args = parser.parse_args()
    split_ocr_texts(Path(args.input_root), Path(args.output_root), page_limit=args.page_limit)
