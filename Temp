import json
from pathlib import Path

def combined_json_to_markdown_tree(
    input_root: str,
    output_root: str,
    in_filename: str = "combined.json",
    out_filename: str = "combined.md",
    num_instructions: int = 23
) -> None:
    in_root = Path(input_root)
    out_root = Path(output_root)

    for json_path in in_root.rglob(in_filename):
        try:
            data = json.loads(json_path.read_text(encoding="utf-8"))
        except Exception:
            continue

        parts = []
        case_title = json_path.parent.name
        parts.append(f"# {case_title} â€” Combined Extraction\n")

        for i in range(1, num_instructions + 1):
            orig = (data.get(f"original_extraction_information_{i}") or "").strip()
            rev  = (data.get(f"revised_extraction_information_{i}")  or "").strip()
            ctx  = (data.get(f"extracted_context_{i}")               or "").strip()

            if not (orig or rev or ctx):
                continue

            parts.append(f"## Step {i}\n")

            if orig:
                parts.append("**Original Extraction Information**\n")
                q_orig = "> " + orig.replace("\n", "\n> ")
                parts.append(q_orig + "\n")

            if rev:
                parts.append("**Revised Extraction Information**\n")
                q_rev = "> " + rev.replace("\n", "\n> ")
                parts.append(q_rev + "\n")

            if ctx:
                parts.append("**Extracted Context**\n")
                parts.append("```text")
                parts.append(ctx)
                parts.append("```\n")

        md_text = "\n".join(parts).strip() + "\n"

        rel_dir = json_path.parent.relative_to(in_root)
        out_dir = out_root / rel_dir
        out_dir.mkdir(parents=True, exist_ok=True)
        (out_dir / out_filename).write_text(md_text, encoding="utf-8")
