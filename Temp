from pathlib import Path
import json, mimetypes, asyncio

# --------------------------------------------------------------------
# helper: pick a reasonable MIME for the multipart request
def _mime(p: Path) -> str:
    return mimetypes.guess_type(p.name)[0] or "application/octet-stream"


# --------------------------------------------------------------------
async def vision_extract_mirror_tree(
    input_root: str | Path = "Output_Files/HELIX",   # where page‑*.jpg live
    output_root: str | Path = "Output_Final/HELIX",  # where *.json will go
    prompt_path: str | Path = "prompt_1.txt",
    schema_path: str | Path = "schema.json",
) -> None:
    """
    Walks every *.jpg below `input_root`, calls `vision_structure`, and stores
    the JSON under `output_root`, preserving the same sub‑folder hierarchy and
    filename stem (page-1.jpg -> page-1.json).

    Processing is strictly sequential (one request at a time).
    """
    input_root  = Path(input_root).expanduser().resolve()
    output_root = Path(output_root).expanduser().resolve()
    output_root.mkdir(parents=True, exist_ok=True)

    prompt = Path(prompt_path).read_text(encoding="utf-8")
    schema = json.loads(Path(schema_path).read_text(encoding="utf-8"))

    img_paths = sorted(input_root.rglob("*.jpg"))
    if not img_paths:
        raise FileNotFoundError(f"No JPG images found under {input_root}")

    for img in img_paths:
        # --- call the Vision endpoint ---------------------------------------
        with img.open("rb") as fh:
            files = [("images", (img.name, fh, _mime(img)))]
            response = await vision_structure(schema, prompt, files)

        # --- compute mirrored JSON path --------------------------------------
        rel_path  = img.relative_to(input_root)          # e.g. Reauth_01/pdf_A/page-1.jpg
        json_path = output_root / rel_path.with_suffix(".json")
        json_path.parent.mkdir(parents=True, exist_ok=True)

        json_path.write_text(
            json.dumps(response, ensure_ascii=False, indent=2), encoding="utf-8"
        )
        print(f"✓ {rel_path}  →  {json_path.relative_to(output_root)}")


# ----------------- Example (Jupyter/IPython) --------------------------
# await vision_extract_mirror_tree()   # uses defaults above
# await vision_extract_mirror_tree(
#         input_root="Output_Files/HELIX",
#         output_root="Output_Final/HELIX",
#         prompt_path="prompt_1.txt",
#         schema_path="schema.json")



