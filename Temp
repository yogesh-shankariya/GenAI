import json
from pathlib import Path
from typing import Dict

def combine_across_all_instructions(
    input_root: str,    # e.g. ".../Combined_Json_Step_1"
    output_root: str,   # e.g. ".../Combined_Json_Final"
    num_instructions: int = 23,
    out_filename: str = "combined.json",
) -> None:
    """
    Input hierarchy example:
      <input_root>/
        A20241114493312/                     # CASE_GROUP (may exist)
          REVISED_EXTRACTION_INFORMATION_1/
            CAROLL SB-.../combined.json
          REVISED_EXTRACTION_INFORMATION_2/
            CAROLL SB-.../combined.json
          ...
        (repeat for other groups)

    Output:
      <output_root>/<CASE_GROUP>/<CASE_NAME>/combined.json
      where combined.json is:
      {
        "revised_extraction_information_1":  "<text from REI_1/CASE/combined.json>",
        ...
        "revised_extraction_information_23": "<text from REI_23/CASE/combined.json>"
      }
    """
    in_root = Path(input_root)
    out_root = Path(output_root)

    def _read_text_from_combined(p: Path) -> str:
        if not p.exists():
            return ""
        try:
            obj = json.loads(p.read_text(encoding="utf-8"))
        except Exception:
            return ""
        if isinstance(obj, dict):
            # your earlier step wrote {"extracted_text": "..."}
            txt = obj.get("extracted_text") or obj.get("Extracted_Text") or obj.get("text") or ""
            return txt.strip() if isinstance(txt, str) else json.dumps(txt, ensure_ascii=False)
        return str(obj)

    # Determine if there is a CASE_GROUP layer (e.g., A2024...).
    # If REI_* dirs are directly under input_root, treat input_root as a single group.
    group_dirs = [p for p in in_root.iterdir() if p.is_dir()]
    has_group_layer = any((g / "REVISED_EXTRACTION_INFORMATION_1").exists() for g in group_dirs)
    if not has_group_layer:
        group_dirs = [in_root]

    for group_dir in sorted(group_dirs):
        # discover all case folders that appear under any REI dir
        rei_dirs = sorted(group_dir.glob("REVISED_EXTRACTION_INFORMATION_*"))
        if not rei_dirs:
            continue

        case_names = set()
        for rei in rei_dirs:
            for case_dir in rei.iterdir():
                if case_dir.is_dir():
                    case_names.add(case_dir.name)

        # build one combined JSON per case
        for case_name in sorted(case_names):
            combined: Dict[str, str] = {}
            for i in range(1, num_instructions + 1):
                rei_case_combined = group_dir / f"REVISED_EXTRACTION_INFORMATION_{i}" / case_name / "combined.json"
                combined[f"revised_extraction_information_{i}"] = _read_text_from_combined(rei_case_combined)

            out_dir = out_root if not has_group_layer else (out_root / group_dir.name)
            out_dir = out_dir / case_name
            out_dir.mkdir(parents=True, exist_ok=True)
            (out_dir / out_filename).write_text(json.dumps(combined, indent=2, ensure_ascii=False), encoding="utf-8")
