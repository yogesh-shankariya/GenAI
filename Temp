from __future__ import annotations

import json
import os
from typing import Any, Dict, Optional

import httpx
from dotenv import load_dotenv

from .auth import OAuthCredentials, TokenCache, is_token_valid

load_dotenv()

__all__ = ["HorizonApiClient"]


class HorizonApiClient:
    """Async wrapper around the Horizon text-structure endpoint."""

    _TOKEN_EP: str = "/oauth2/token"
    _STRUCTURE_EP: str = "/v2/text/structures"

    # ------------------------------------------------------------------ #
    def __init__(
        self,
        *,
        gateway: str | None = None,
        client_id: str | None = None,
        client_secret: str | None = None,
        secure: bool = True,
        token_store: TokenCache | None = None,
        timeout: int = 3000,
    ) -> None:
        creds = OAuthCredentials(
            client_id=client_id or os.getenv("HORIZON_CLIENT_ID"),
            client_secret=client_secret or os.getenv("HORIZON_CLIENT_SECRET"),
            gateway=gateway or os.getenv("HORIZON_GATEWAY"),
        )

        self._creds = creds
        self._secure = secure
        self._proto = "https" if secure else "http"
        self._timeout = timeout

        self._token_store = token_store or TokenCache()
        self._token_payload: Optional[Dict[str, Any]] = None  # lazy-loaded

    # ------------------------------ PUBLIC ----------------------------- #
    async def marshall_into_json(
        self,
        *,
        schema: Dict[str, Any] | str,
        prompt: str,
        params: Dict[str, Any] | None = None,
    ) -> Dict[str, Any]:
        """
        Ask Horizon to transform *prompt* so that it respects *schema*.
        Returns the “content” field (empty dict on error).
        """
        token = await self._get_token()

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
        }
        payload = {"prompt": prompt, "output": schema, "stream": False}

        async with httpx.AsyncClient(timeout=self._timeout, verify=False) as client:
            resp = await client.post(
                f"{self._proto}://{self._creds.gateway}{self._STRUCTURE_EP}",
                json=payload,
                headers=headers,
                params=params,
            )
            resp.raise_for_status()

        try:
            return resp.json().get("content", {})
        except json.JSONDecodeError as exc:
            raise RuntimeError("Could not decode Horizon response") from exc

    # ----------------------- TOKEN HANDLING (PRIVATE) ------------------ #
    async def _get_token(self) -> str:
        if self._token_payload is None:
            self._token_payload = self._token_store.load()

        if not is_token_valid(self._token_payload):
            self._token_payload = await self._request_new_token()
            self._token_store.save(self._token_payload)

        return self._token_payload["access_token"]

    async def get_token(self) -> str:
        """Public accessor for a cached or freshly requested OAuth token."""
        return await self._get_token()

    async def _request_new_token(self) -> Dict[str, Any]:
        headers = {"Content-Type": "application/json"}
        payload = {
            "client_id": self._creds.client_id,
            "client_secret": self._creds.client_secret,
            "grant_type": "client_credentials",
        }

        async with httpx.AsyncClient(timeout=self._timeout, verify=False) as client:
            resp = await client.post(
                f"{self._proto}://{self._creds.gateway}{self._TOKEN_EP}",
                json=payload,
                headers=headers,
            )
            resp.raise_for_status()

        data = resp.json()
        import datetime as dt

        data["access_token_created_at"] = dt.datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")
        return data
