"""
Qdrant vector store utilities.

This module encapsulates common operations for storing embeddings in
a Qdrant vector database. It supports creating collections with the
appropriate vector size and distance metric, as well as upserting
points with metadata.

Example usage::

    from vector_store import get_client, ensure_collection, upsert_vectors

    client = get_client(host="localhost", port=6333)
    collection_name = "alerts"
    vector_size = 1024
    ensure_collection(client, collection_name, vector_size)
    upsert_vectors(client, collection_name, ids, vectors, payloads)

"""

from __future__ import annotations

import uuid
from typing import Any, Dict, List, Optional

from qdrant_client import QdrantClient
from qdrant_client.http.models import (
    Distance,
    PointStruct,
    VectorParams,
)


def get_client(host: str = "localhost", port: int = 6333, api_key: Optional[str] = None) -> QdrantClient:
    """Instantiate a Qdrant client.

    Args:
        host: Hostname where Qdrant is running.
        port: Port number for Qdrant.
        api_key: Optional API key for Qdrant Cloud.

    Returns:
        A ``QdrantClient`` instance.
    """
    return QdrantClient(host=host, port=port, api_key=api_key)


def ensure_collection(
    client: QdrantClient,
    collection_name: str,
    vector_size: int,
    *,
    distance: str = "Cosine",
) -> None:
    """Ensure that a collection exists in Qdrant.

    If the collection already exists, no action is taken. Otherwise,
    a new collection is created with the specified vector size and distance
    metric.

    Args:
        client: A Qdrant client instance.
        collection_name: Name of the collection.
        vector_size: Dimensionality of the vectors.
        distance: Distance metric to use ("Cosine", "Euclid", etc.).
    """
    existing = {col.name for col in client.get_collections().collections}
    if collection_name not in existing:
        client.recreate_collection(
            collection_name=collection_name,
            vectors_config=VectorParams(size=vector_size, distance=getattr(Distance, distance.upper())),
        )


def upsert_vectors(
    client: QdrantClient,
    collection_name: str,
    ids: List[str],
    vectors: List[List[float]],
    payloads: List[Dict[str, Any]],
) -> None:
    """Upsert points into a Qdrant collection.

    Args:
        client: Qdrant client instance.
        collection_name: Name of the target collection.
        ids: A list of point IDs. Must be the same length as ``vectors``.
        vectors: A list of embedding vectors.
        payloads: A list of metadata dictionaries, one per point.

    Raises:
        ValueError: If the lengths of ``ids``, ``vectors``, and ``payloads`` do not match.
    """
    if not (len(ids) == len(vectors) == len(payloads)):
        raise ValueError("The lengths of ids, vectors, and payloads must be equal.")
    points: List[PointStruct] = []
    for pid, vec, payload in zip(ids, vectors, payloads):
        # If an ID is None or empty, generate a new UUID4
        point_id = pid or uuid.uuid4().hex
        points.append(PointStruct(id=point_id, vector=vec, payload=payload))
    client.upsert(collection_name=collection_name, points=points)
