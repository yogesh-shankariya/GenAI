from typing import List, Dict, Tuple
import re

PAGE_TAG_RE = re.compile(r"<ocr_service_page_start>\s*(\d+)", re.I)

def _chunk_context(full_text: str,
                   pages_per_chunk: int = 50,
                   overlap: int = 20) -> List[str]:
    # ─────────────── record every tag position ───────────────
    positions: List[Tuple[int, int]] = []
    for m in PAGE_TAG_RE.finditer(full_text):
        page = int(m.group(1))
        # skip duplicates: keep first occurrence only
        if not positions or positions[-1][0] != page:
            positions.append((page, m.start()))

    if not positions:
        return [full_text]                # no tags at all → single chunk

    # sentinel so the last page gets a slice end
    positions.append((positions[-1][0] + 1, len(full_text)))

    # page → (start, end)
    page_slice: Dict[int, Tuple[int, int]] = {
        p: (start, positions[i + 1][1])
        for i, (p, start) in enumerate(positions[:-1])
    }
    all_pages = sorted(page_slice)         # e.g. [1,2,3,5,6,7,12,…]

    # ─────────────── build overlapping windows ───────────────
    step = pages_per_chunk - overlap
    chunks: List[str] = []

    start_idx = 0                          # index into all_pages list
    while start_idx < len(all_pages):
        # window of page indices we want
        window_pages = []
        first_page = all_pages[start_idx]
        last_allowed = first_page + pages_per_chunk - 1
        idx = start_idx
        # collect pages while within window
        while idx < len(all_pages) and all_pages[idx] <= last_allowed:
            window_pages.append(all_pages[idx])
            idx += 1

        # slice boundaries = first page start … last page end
        chunk_start = page_slice[window_pages[0]][0]
        chunk_end   = page_slice[window_pages[-1]][1]
        chunks.append(full_text[chunk_start:chunk_end])

        # advance by `step` pages in the ordered page list
        start_idx += max(1, step)          # avoid infinite loop on tiny docs

    return chunks
