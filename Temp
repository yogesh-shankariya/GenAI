Below are **four complete Pydantic schemas**—one for each of the JSON examples you showed.
Copy each snippet into its own module (or the same file, if that’s your convention) and adjust import paths as needed.

---

```python
# cover_page_schema.py
from pydantic import BaseModel, Field


class CoverPagePayload(BaseModel):
    """
    Indicates whether the current page is a cover page.
    """

    ind: str = Field(
        ...,
        description="Either `cover_page` or `not cover_page`",
    )

    model_config = {"extra": "forbid"}
```

---

```python
# header_segmentation_sec_heading_schema.py
from typing import List
from pydantic import BaseModel, Field


class SectionHeading(BaseModel):
    section_heading: str = Field(
        ...,
        description="Identified section heading in a page",
    )
    page_number: str = Field(
        ...,
        description="Page number where the section heading appears",
    )
    reasoning_for_section_heading: str = Field(
        ...,
        description="Reasoning for identifying this text as a section heading",
    )

    model_config = {"extra": "forbid"}


class HeaderSegmentationSectionHeadingPayload(BaseModel):
    """
    Collection of section headings detected within the document.
    """

    sections: List[SectionHeading] = Field(
        ...,
        description="List of detected section headings",
    )

    model_config = {"extra": "forbid"}
```

---

```python
# header_segmentation_final_output_schema.py
from typing import List
from pydantic import BaseModel, Field


class EncounterSegment(BaseModel):
    segment_sequence: str = Field(
        ...,
        description="Sequence number of the encounter segment",
    )
    segment_type: str = Field(
        "encounter",
        description="Type of segment (fixed to 'encounter')",
    )
    segment_start_page: str = Field(
        ...,
        description="Page number where the encounter segment starts",
    )
    reasoning_for_encounter: str = Field(
        ...,
        description="Reasoning for classifying the segment as an encounter",
    )

    model_config = {"extra": "forbid"}


class HeaderSegmentationFinalOutputPayload(BaseModel):
    """
    Details of all encounter segments detected in header segmentation.
    """

    encounters: List[EncounterSegment] = Field(
        ...,
        description="List of encounter segments",
    )

    model_config = {"extra": "forbid"}
```

---

```python
# encounter_details_schema.py
from typing import List
from pydantic import BaseModel, Field


class EncounterDetail(BaseModel):
    segment_sequence: str = Field(
        ...,
        description="Sequence number of the encounter detail",
    )
    segment_type: str = Field(
        ...,
        description="Type of segment",
    )
    segment_start_page: str = Field(
        ...,
        description="Page number where the encounter starts",
    )

    model_config = {"extra": "forbid"}


class Encounter(BaseModel):
    encounter_details: List[EncounterDetail] = Field(
        ...,
        description="List of detailed encounter segments",
    )

    model_config = {"extra": "forbid"}


class EncounterDetailsPayload(BaseModel):
    """
    Wrapper object for encounter details.
    """

    encounter: Encounter = Field(
        ...,
        description="Encounter object containing detailed segments",
    )

    model_config = {"extra": "forbid"}
```

Each schema mirrors its respective JSON structure, enforces field presence with `...`, forbids unexpected fields via `model_config = {"extra": "forbid"}`, and includes concise field descriptions for clarity.
