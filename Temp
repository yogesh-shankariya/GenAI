import re
from pathlib import Path
import pandas as pd


def extract_err_warn_with_s3(log_source):
    """
    Return two DataFrames:
      error_df   : ['message', 'count', 's3_path']
      warning_df : ['message', 'count', 's3_path']

    Logic:
      - Detect blocks that start at:  "in main_test: ***********"
      - Grab S3 path from the next line that contains "Received binary S3 path:"
      - All ERROR/WARNING lines that fall inside that block inherit the block's s3_path
    """

    # -------- read ----------
    if isinstance(log_source, (str, Path)) and Path(str(log_source)).exists():
        text = Path(str(log_source)).read_text(encoding="utf-8", errors="ignore")
    else:
        text = str(log_source)
    lines = text.splitlines()

    # -------- regexes --------
    ts_re   = re.compile(r"^\[(?P<ts>\d{4}-\d{2}-\d{2} .*?)\]")          # just to know itâ€™s a log line
    start_re = re.compile(r"in\s+main_test:\s+\*+")                      # marker line
    s3_re    = re.compile(r"Received binary S3 path:\s*([^\s]+)")        # S3 path grabber
    lvl_re   = re.compile(
        r"^\[\d{4}-\d{2}-\d{2} .*?\]\s+(?P<lvl>ERROR|WARNING)\s+\[trace_id=.*?\]\s+in\s+[^:]+:\s+(?P<msg>.*)$"
    )

    # -------- find blocks (start_idx, end_idx, s3_path) -------------
    blocks = []
    current = None

    for i, ln in enumerate(lines):
        if start_re.search(ln):
            # close previous
            if current is not None:
                current["end"] = i - 1
                blocks.append(current)
            current = {"start": i, "end": None, "s3": None}

            # try to read S3 path either on same line or the next few lines
            # (your examples show it on the very next line)
        if current is not None and current["s3"] is None:
            m = s3_re.search(ln)
            if m:
                current["s3"] = m.group(1).strip()

    # close last block
    if current is not None:
        current["end"] = len(lines) - 1
        blocks.append(current)

    # Map every line index to its block's s3_path
    idx_to_s3 = {}
    for b in blocks:
        for j in range(b["start"], b["end"] + 1):
            idx_to_s3[j] = b["s3"]

    # -------- collect error/warning rows ----------------------------
    err_rows, warn_rows = [], []
    for i, ln in enumerate(lines):
        m = lvl_re.match(ln)
        if not m:
            continue
        msg = m.group("msg").strip()
        lvl = m.group("lvl")
        s3 = idx_to_s3.get(i)  # None if outside any block
        row = {"message": msg, "s3_path": s3}
        if lvl == "ERROR":
            err_rows.append(row)
        else:
            warn_rows.append(row)

    # -------- aggregate ---------------------------------------------
    def agg(rows):
        if not rows:
            return pd.DataFrame(columns=["message", "count", "s3_path"])
        df = pd.DataFrame(rows)
        return (df.groupby(["message", "s3_path"], dropna=False)
                  .size()
                  .reset_index(name="count")
                  .sort_values("count", ascending=False)
                  .reset_index(drop=True))

    error_df   = agg(err_rows)
    warning_df = agg(warn_rows)

    return error_df, warning_df
