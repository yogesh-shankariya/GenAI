"""
Centralised CSV logger for per-question metrics
----------------------------------------------
• Thread- & async-safe (uses file lock)
• Writes header once
• Appends one row per user question
"""
import csv, os, asyncio, hashlib, time
from pathlib import Path
from typing import Dict, Any
from filelock import FileLock           # pip install filelock

CSV_PATH = Path(os.getenv("METRICS_CSV", "conversation_metrics.csv")).resolve()
_LOCK    = FileLock(str(CSV_PATH) + ".lock")

_HEADER = [                     # column order ⇒ rename freely
    "session_id",
    "question",
    "tokens",
    "guardrail_ms",
    "guardrail_outcome",
    "llm_ms",
    "llm_answer",
    "json_ms",
    "json_answer",
    "faith_ms",
    "faith_score",
    "faith_just",
    "rel_ms",
    "rel_score",
    "rel_just",
    "rec_ms",
    "rec_questions",
]

def _write_header_if_needed() -> None:
    if CSV_PATH.exists() and CSV_PATH.stat().st_size:
        return
    with _LOCK:
        with CSV_PATH.open("w", newline="", encoding="utf-8") as fh:
            csv.writer(fh).writerow(_HEADER)

async def append_row(row: Dict[str, Any]) -> None:
    """Accept plain dict, coerce everything to str & append."""
    _write_header_if_needed()
    str_row = [str(row.get(col, "")) for col in _HEADER]
    loop = asyncio.get_running_loop()
    await loop.run_in_executor(None, _sync_write, str_row)

def _sync_write(str_row):
    with _LOCK:
        with CSV_PATH.open("a", newline="", encoding="utf-8") as fh:
            csv.writer(fh).writerow(str_row)

# Utility: quick unique ID when caller hasn’t supplied one
def new_session_id() -> str:
    return hashlib.sha1(f"{time.time_ns()}".encode()).hexdigest()[:16]
