import json
from pathlib import Path

def _get_ci(d: dict, key: str, fallbacks=()):
    """case-insensitive get with optional fallback keys"""
    if key in d:
        return d[key]
    lk = key.lower()
    for k, v in d.items():
        if k.lower() == lk:
            return v
    for fb in fallbacks:
        if fb in d:
            return d[fb]
        fl = fb.lower()
        for k, v in d.items():
            if k.lower() == fl:
                return v
    return ""

def map_pairs_with_combined(
    combined_root: str,                # e.g. ".../Combined_Json_Final"
    pair_extraction_json: str,         # e.g. "Paired_Extraction_Information.json"
    output_root: str,                  # e.g. ".../Combined_Json_Mapped"
    num_instructions: int = 23,
    in_filename: str = "combined.json",
    out_filename: str = "combined.json",
) -> None:
    """
    For each case combined.json under combined_root, write a new combined.json under output_root:
    {
      "original_extraction_information_1": "...",
      "revised_extraction_information_1": "...",
      "extracted_context_1": "...",
      ...
      "original_extraction_information_23": "...",
      "revised_extraction_information_23": "...",
      "extracted_context_23": "..."
    }
    """
    combined_root = Path(combined_root)
    output_root = Path(output_root)

    # Load the original/revised pairs once
    pairs = json.loads(Path(pair_extraction_json).read_text(encoding="utf-8"))

    # Walk every case combined.json under combined_root (keeps any group/case hierarchy)
    for cmb_path in combined_root.rglob(in_filename):
        try:
            case_combined = json.loads(cmb_path.read_text(encoding="utf-8"))
        except Exception:
            continue

        out_obj = {}
        for i in range(1, num_instructions + 1):
            orig = _get_ci(pairs, f"original_extraction_information_{i}")
            rev  = _get_ci(pairs, f"revised_extraction_information_{i}")
            ctx  = _get_ci(
                case_combined,
                f"revised_extraction_information_{i}",
                fallbacks=(f"Extracted_Text_{i}", f"extracted_context_{i}")
            )
            if not isinstance(ctx, str):  # normalize to string
                ctx = json.dumps(ctx, ensure_ascii=False)

            out_obj[f"original_extraction_information_{i}"] = orig if isinstance(orig, str) else json.dumps(orig, ensure_ascii=False)
            out_obj[f"revised_extraction_information_{i}"]  = rev  if isinstance(rev,  str) else json.dumps(rev,  ensure_ascii=False)
            out_obj[f"extracted_context_{i}"]                = ctx.strip()

        # Mirror the hierarchy in output_root
        rel_dir = cmb_path.parent.relative_to(combined_root)
        out_dir = output_root / rel_dir
        out_dir.mkdir(parents=True, exist_ok=True)
        (out_dir / out_filename).write_text(json.dumps(out_obj, indent=2, ensure_ascii=False), encoding="utf-8")



map_pairs_with_combined(
    combined_root="/.../Combined_Json_Final",
    pair_extraction_json="/.../Paired_Extraction_Information.json",
    output_root="/.../Combined_Json_Mapped",
    num_instructions=23
)
