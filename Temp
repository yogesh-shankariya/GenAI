from pathlib import Path
import json
import mimetypes
import asyncio

# ---------- helper -----------------------------------------------------------
def _mime(path: Path) -> str:
    return mimetypes.guess_type(path.name)[0] or "application/octet-stream"


# ---------- main -------------------------------------------------------------
async def sequential_vision_extract(
    input_dir: str | Path = "output_images",
    output_dir: str | Path = "output_final",
    prompt_path: str | Path = "prompt_1.txt",
    schema_path: str | Path = "schema.json",
) -> None:
    """
    Reads every *.jpg image under `input_dir`, sends it to `vision_structure`
    (await‑able), and stores the JSON result under `output_dir` using the same
    filename stem (page‑1.json, page‑2.json, …).

    Processing is strictly sequential – one request at a time.
    """
    input_dir  = Path(input_dir).expanduser().resolve()
    output_dir = Path(output_dir).expanduser().resolve()
    output_dir.mkdir(parents=True, exist_ok=True)

    prompt = Path(prompt_path).read_text(encoding="utf-8")
    schema = json.loads(Path(schema_path).read_text(encoding="utf-8"))

    img_paths = sorted(input_dir.rglob("*.jpg"))
    if not img_paths:
        raise FileNotFoundError(f"No JPG images found under {input_dir}")

    for img in img_paths:
        with img.open("rb") as fh:
            files = [("images", (img.name, fh, _mime(img)))]
            response = await vision_structure(schema, prompt, files)

        out_path = output_dir / f"{img.stem}.json"
        out_path.write_text(json.dumps(response, ensure_ascii=False, indent=2),
                            encoding="utf-8")
        print(f"✓ {img.name} → {out_path.relative_to(output_dir.parent)}")


# ---------- usage (Jupyter/IPython cell) -------------------------------------
# await sequential_vision_extract()          # runs with default paths
# await sequential_vision_extract("output_images", "output_final",
#                                 "prompt_1.txt", "schema.json")
